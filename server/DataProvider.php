<?php
require 'RateLimit.php';

class DataProvider
{
	/**************************************************************************************************
	 * CONST MEMBERS
	 **************************************************************************************************/
	const OK = 200; // OK
	const BadRequest = 400; // Invalid params (string/integer) OR required parameter was not provided
	const Unautorized = 401; // No API key provided; Invalid API key;
	const NotFound = 404; // ID or name provided does not match any existing resource
	const RateLimitExceeded = 429; // Unregulated API calls
	const InternalServerError = 500; // Unexpected condition or exception which prevented the server from fulfilling an API request
	const ServiceUnavailable = 503; // Server is currently unavailable to handle requests because of an unknown reason
	
	/**************************************************************************************************
	 * PRIVATE MEMBERS
	 **************************************************************************************************/
	private $Config; // Loaded JSON conf file
	private $MongoDB; // MongoDB manager
	private $cURL; // cURL handle
	
	private $last_error_code; // This is the last error code
	private $last_error_message; // This is the last error message

	/**************************************************************************************************
	 * PUBLIC METHODS
	 **************************************************************************************************/
	/*
	 * cTor
	 */
	public function __construct()
	{
		$this->MongoDB = null; // Init MongoDB Manager
		$this->cURL = null; // Init cURL for League of Legends API requests
		
		$this->last_error_code = 0; // Contains the last error code - THIS IS NOT LEAGUE OF LEGENDS API ERROR CODE IT'S INTERNAL
		$this->last_error_message = ""; // Contains the last error message - THIS IS NOT LEAGUE OF LEGENDS API ERROR MESSAGE IT'S INTERNAL
	}
	
	
	
	public function setAPIConfig($conf_file)
	{
		// file_get_contents doesn't work; use bufferisation and include file
		ob_start();
			require_once $conf_file;
			$file = ob_get_contents();
		ob_end_clean();
		$this->Config = json_decode($file, true);

		// Check if config is loaded
		if(!count($this->Config) > 0)
			die("Unable to load '$conf_file'.\r\n");

		// JSON Validation: API
		if(count($this->Config['api']) > 0)
		{
			// The following fields are required
			$require_fields = ["key" => "is_string",
							   "1" => "is_int",
							   "10" => "is_int",
							   "600" => "is_int"];
			
			// Check for required fields
			foreach($require_fields as $key => $validator)
			{
				if(!(isset($this->Config['api'][$key]) && $validator($this->Config['api'][$key])))
					die("'$conf_file' File validation fail. ['api']['$key'] doesn't exist or validator ($validator) return false.\r\n");
			}
		}
		else
			die("'$conf_file' File validation fail. ['api'] doesn't exist.\r\n");


		// JSON Validation: Requests
		// Format: key1.key2.key3 (current refer to the current request)
		if(count($this->Config['template_validation']) == 0)
			die("'$conf_file' File validation fail. ['template_validation'] doesn't exist (which mean that we can't validate templates URL).\r\n");
		
		if(count($this->Config['requests']) > 0)
		{
			// The following fields are required in each request
			$require_fields = ["descr", "url", "cache"];
			
			foreach($this->Config['requests'] as $request_name => $request_configuration)
			{
				// Check for required fields
				foreach($require_fields as $key)
				{
					if(!isset($request_configuration[$key]))
						die("'$conf_file' File validation fail. ['requests']['$request_name']['$key'] doesn't exist or is empty.\r\n");
				}

				// URL template validation
				preg_match_all('/(\{[A-Za-z_]+\})/', $request_configuration['url'], $matches);
				$url_templates = array_unique($matches[0]);
				$this->Config['requests'][$request_name]['url_templates'] = $url_templates;
				
				foreach($url_templates as $template)
				{
					/* Will generate two fields per requests.
					 * 'url_templates' will contains every templates parameters ({id}, {name}, {region}, ...)
					 * 'url_templates_values' will contains every values for templates validation and replacement.
					 * The value can be an array: so the parameter provided must be in_array to be validate and replaced.
					 * (SPECIAL CASE FOR {plaform} which will be generated by {region} parameter)
					 * The value can be a regex: so the parameter must match the regex to be validate and replaced.
					 * Raw value: the template will be replaced by this raw value.
					 */
					if(isset($this->Config['template_validation'][$template]) && !empty($this->Config['template_validation'][$template]))
					{
						$exploded = explode('.', $this->Config['template_validation'][$template]);
						$replacement_value = &$this->Config;
						
						foreach($exploded as $i => $key)
						{
							if(isset($replacement_value[$key]))
								$replacement_value = &$replacement_value[$key];
							elseif($key == "current" && is_array($replacement_value))
							{
								if(isset($replacement_value[$request_name][$exploded[$i+1]]))
								{
									$this->Config['requests'][$request_name]['url_templates_values'][$template] = $replacement_value[$request_name][$exploded[$i+1]];
									break;									
								}	
								else
									die("'$conf_file' File validation fail. ['template_validation']['$template'] replacement doesn't exist for [current=$request_name].\r\n");
							}
							else
								die("'$conf_file' File validation fail. ['template_validation']['$template'] replacement doesn't exist.\r\n");
						}

						if(!isset($this->Config['requests'][$request_name]['url_templates_values'][$template]))
							$this->Config['requests'][$request_name]['url_templates_values'][$template] = $replacement_value;
					}
					else
						die("'$conf_file' File validation fail. No rule for template : $template.\r\n");
				}
			}
		}
		else
			die("'$conf_file' No requests available.\r\n");
	}

	
	
	
	public function setMongoDB($host, $port, $username=null, $password=null)
	{
		if(!is_null($username) && !is_null($password))
			$this->MongoDB = new MongoDB\Driver\Manager("mongodb://".$username.":".$password."@".$host.":".$port); // Init MongoDB Manager
		else
			$this->MongoDB = new MongoDB\Driver\Manager("mongodb://".$host.":".$port); // Init MongoDB Manager
		
		$this->cURL = curl_init(); // Init cURL for League of Legends API requests
	}
	
	
	
	/*
	 * dTor
	 */
	public function __destruct()
	{
		curl_close($this->cURL);
	}

	
	
	/* This function parse a formatted request and return the result
	 * Format: command [param1=value1] [param2=value2_0,value2_1,value2_2] [param3=value3]
	 * Look for supported request
	 * Parse parameters from query
	 * Replace URL templates parameters by parameters provided in the query
	 * Retrieve result (Result can be cached, or fresh)
	 */
	public function Query($q)
	{
		$Query= json_decode($q, true);
		// Look for supported request
		$request_configuration = $this->getRequestConfiguration($Query["QueryName"]);
		if(is_null($request_configuration))
			return $this->json_formatted_error(DataProvider::BadRequest, "The request is not supported/implemented.");

		// Parse query parameters
		$request_parameters = $this->getRequestParameters($Query["QueryParams"]);
		// Get request URL (replace templates parameters)
		$api_url = $this->getRequestURL($request_configuration, $request_parameters);
		if($this->error())
			return $this->json_formatted_error();

		if($request_parameters["id_multi"] === true)
		{
			$result = array();
			$invalidcached_data = array();
			
			// Request for multiple IDs or NAMEs
			$replacement_type = isset($request_parameters["id"]) ? "id" : "name";
			// Get valid cached request
			foreach($request_parameters[$replacement_type] as $value)
			{
				$tmp_api_url = str_replace('{'.$replacement_type.'}', $value, $api_url);
				$result_tmp = $this->getCachedRequest($tmp_api_url, time()-$request_configuration['cache']);
				if($result_tmp !== false)
				{
					$result_tmp = json_decode($result_tmp, true);
					foreach($result_tmp as $k => $v)
					{
						if($k == $this->normalizedSummonerName($value))
							$result[$this->normalizedSummonerName($value)] = $v;
						else
							$result[$this->normalizedSummonerName($value)][$k] = $v;
					}
				}
				else
					$invalidcached_data[] = $value;
			}
			
			// Check if invalidcached_data is empty
			if(!empty($invalidcached_data))
			{
				$max_at_once = 0;
				$tmp_value = "";
				$invalidcached_data_count = count($invalidcached_data);
				
				for($i=0; $i<$invalidcached_data_count; $i++)
				{
					if($max_at_once+1 == $request_configuration['max_at_once'])
					{
						$tmp_value .= $invalidcached_data[$i];
						$tmp_api_url = str_replace('{'.$replacement_type.'}', $tmp_value, $api_url);
						$result_tmp = json_decode($this->callRiotAPI($tmp_api_url, $request_parameters), true);
						
						foreach($result_tmp as $k => $v)
						{
							if($k == $this->normalizedSummonerName($value))
								$result[$this->normalizedSummonerName($value)] = $v;
							else
								$result[$this->normalizedSummonerName($value)][$k] = $v;
						}
						
						$max_at_once = 0;
					}
					else if($i == $invalidcached_data_count-1)
					{
						$tmp_value .= $invalidcached_data[$i];
						$tmp_api_url = str_replace('{'.$replacement_type.'}', $tmp_value, $api_url);
						$result_tmp = json_decode($this->callRiotAPI($tmp_api_url, $request_parameters), true);
						
						foreach($result_tmp as $k => $v)
						{
							if($k == $this->normalizedSummonerName($value))
								$result[$this->normalizedSummonerName($value)] = $v;
							else
								$result[$this->normalizedSummonerName($value)][$k] = $v;
						}
						
						$max_at_once = 0;
					}
					else
					{
						$tmp_value .= $invalidcached_data[$i].",";
						$max_at_once += 1;
					}			
				}			
			}
			
			return json_encode($result, JSON_PRETTY_PRINT);
		}
		else
		{
			// Request for one ID or NAME
			if(!is_null($request_parameters["id"]))
				$api_url = str_replace('{id}', $request_parameters["id"], $api_url);

			$result = $this->getCachedRequest($api_url, time()-$request_configuration['cache']);
			if($result === false)
				return $this->callRiotAPI($api_url, $request_parameters); // Return fresh data (cache has expired or no cache for this request)
			
			return json_encode(json_decode($result, true), JSON_PRETTY_PRINT); // Return cached request
		}
	}

	
	
	
	/**************************************************************************************************
	 * PRIVATES METHODS
	 **************************************************************************************************/
	/* This function return a normalized summoner name; Without space and in lower characters.
	 */
	private function normalizedSummonerName($name)
	{
		return str_replace(' ', '', strtolower(rawurldecode($name)));
	}
	
	
	
	/* This function return a json formatted error. With last error informations or with data provided.
	 */
	private function json_formatted_error($code=0, $message="")
	{
		if($code === 0 && $message === "")
		{
			$json = '{"status": {"status_code": '.$this->last_error_code.', "message": "'.$this->last_error_message.'"}';
			$this->last_error_code = 0;
			$this->last_error_message = "";

			return $json;
		}

		return '{"status": {"status_code": '.$code.', "message": "'.$message.'"}';
	}
	
	
	
	/* This function set last error informations.
	 * This function always return false.
	 */
	private function setError($code, $message)
	{
		$this->last_error_code = $code;
		$this->last_error_message = $message;

		return false;
	}

	
	
	
	/* This function return true if an error exists. Error need to be released using json_formatted_error.
	 */
	private function error()
	{
		if($this->last_error_code == 0)
			return false;
		else
			return true;
	}

	
	
	
	/* This function parse $query looking for a supported request.
	 * If request is found, return request configuration
	 * Else return null
	 */
	private function getRequestConfiguration($QueryName)
	{
		if(isset($this->Config['requests'][$QueryName]) && count($this->Config['requests'][$QueryName]) > 0)
		{
			return $this->Config['requests'][$QueryName];
		}

		return null;
	}

	
	
	
	/* This function parse $query and retrieves parameters.
	 * Format: request [param1=value1] [param2=value2] [param3=value3_0,value3_1,value3_2]
	 */
	private function getRequestParameters($QueryParams)
	{
		if(is_array($QueryParams) && count($QueryParams) > 0)
		{
			foreach($QueryParams as $key => $value)
			{
				if(is_array($value) && count($value) > 0)
					$request_parameters[$key] = array_map('rawurlencode', array_map('trim', $value));
				else
					$request_parameters[$key] = rawurlencode(trim($value));
			}
		}
	
		// Generate id_type can be id || name || null
		// We also create id_multi [true] if multiple id/name are provided [false] if single id/name or empty
		$request_parameters["id_multi"] = false;
		if(isset($request_parameters["id"]) && is_array($request_parameters["id"]) && count($request_parameters["id"]) > 0)
			$request_parameters["id_multi"] = true;

		return $request_parameters;
	}

	
	
	
	/* This function replace URL templates for a request by their values. IDs and Names won't be replaced.
	 * Return the URL after replacements.
	 */
	private function getRequestURL($request_configuration, $request_parameters)
	{
		// URL templates replacement
		$api_url = $request_configuration['url'];
		foreach($request_configuration['url_templates'] as $template)
		{
			$replacement_value = $request_configuration['url_templates_values'][$template];
			if(!in_array($template, array("{id}", "{name}", "{platform}")))
			{
				$template_nobraces = str_replace(array('{', '}'), '', $template); // Template name without braces
				if(is_array($replacement_value))
				{
					// Replacement value is and array; Validation (in_array) then replacement
					if(in_array($request_parameters[$template_nobraces], $replacement_value))
						$api_url = str_replace($template, $request_parameters[$template_nobraces], $api_url);
					else
						return $this->setError(DataProvider::BadRequest, "$template is not a valid value.");
				}
				else if(is_string($replacement_value) && preg_match('/\/.+\//', $replacement_value) == 1)
				{
					// Replacement value is a regex; Regex (preg_match) then replacement
					if(preg_match($replacement_value, $request_parameters[$template_nobraces]))
						$api_url = str_replace($template, $request_parameters[$template_nobraces], $api_url);
					else
						return $this->setError(DataProvider::BadRequest, "$template is not a valid value.");
				}
				else
					$api_url = str_replace($template, $replacement_value, $api_url); // Simple replacement
			}
			elseif($template == "{platform}")
			{
				// Since platform is defined by region, we must get region value to find platform value
				if(isset($request_parameters["region"]) && !empty($request_parameters["region"]))
				{
					if(in_array($request_parameters["region"], $request_configuration['url_templates_values']["{region}"]))
					{
						$region_to_platform = $this->Config["meta"]["platform"][$request_parameters["region"]];
						$api_url = str_replace("{platform}", $region_to_platform, $api_url);
					}
				}
				else
					return $this->setError(DataProvider::BadRequest, "{platform} present but can't find {region} parameter.");
			}
		}

		return $api_url;
	}

	
	
	
	/* This function take $url and look for cached request.
	 * It will return false if cache has expired or no cached request otherwise it will return cached result.
	 */
	private function getCachedRequest($url, $ttl=946707779)
	{
		$filter = ['_id' => sha1($url), 'time' => ['$gt' => $ttl]];
		$mongodb_query = new MongoDB\Driver\Query($filter);
		$rows = $this->MongoDB->executeQuery('gromp.cache_api', $mongodb_query);
		$rows = $rows->toArray();

		if(count($rows) == 0)
			return false;
		else
			return $rows[0]->result;
	}

	
	
	
	/* This function make a call to $url and cache the result using mongoDB
	 * HTTP status codes are also stored in mongoDB for reporting and audit about good and bad requests
	 * 404 responses are cached AND blacklisted for 12hours because false/bad requests will increase Rate-Limit-Count
	 * which can cause Retry-After (429 RateLimitExceeded).
	 */
	private function callRiotAPI($url, $RequestParams)
	{	
		$region = null;
		if(isset($RequestParams["region"]) && !empty($RequestParams["region"]))
			$region = $RequestParams["region"];
		
		$RateLimit = new RateLimit();
		//$RateLimit->add(new RateLimitFrame(1, 1));
		$RateLimit->add(new RateLimitFrame($this->Config['api'][10], 10));
		$RateLimit->add(new RateLimitFrame($this->Config['api'][600], 600));
		//$RateLimit->add(new RateLimitFrame(360000, 3600));
		
		$memcache_obj = memcache_connect('localhost', 11211);
		$RateLimitMutex = false;
		do
		{
			$RateLimitMutex = $memcache_obj->add('Gromp_RateLimitMutex-'.$region, uniqid(), null, 5);
		}while(!$RateLimitMutex);

		if(!$memcache_obj->add('Gromp_RateLimit-'.$region, serialize($RateLimit)))
			$RateLimit = unserialize($memcache_obj->get('Gromp_RateLimit-'.$region));
		
		$returnValue = $this->json_formatted_error(DataProvider::RateLimitExceeded, "Rate limit exceeded. Wait until : ".date("d/m/Y H:i:s", time()+$RateLimit->getTimeBeforeNextHit()).".");
		
		if($RateLimit->hit() || is_null($region))
		{
			curl_setopt_array($this->cURL, array(CURLOPT_URL => $url,
												 CURLOPT_HEADER => 1,
												 CURLOPT_RETURNTRANSFER => 1,
												 CURLOPT_SSL_VERIFYPEER => 0));
			
			$curl_result["raw"] = curl_exec($this->cURL);
			$curl_result["http_code"] = curl_getinfo($this->cURL, CURLINFO_HTTP_CODE);
			$curl_result["header_size"] = curl_getinfo($this->cURL, CURLINFO_HEADER_SIZE);

			$curl_result["header"] = substr($curl_result["raw"], 0, $curl_result["header_size"]);
			$curl_result["body"] = substr($curl_result["raw"], $curl_result["header_size"]);
			
			/*
			// Rate-Limit-Counter
			if(preg_match("/X-Rate-Limit-Count: ((?:[,]?[0-9]+:[0-9]+)+)/", $curl_result["header"], $matches))
			{
				$rate_limits = explode(',', $matches[1]);
				$rate_limits = array_reverse($rate_limits);

				foreach($rate_limits as $rate)
				{
					preg_match("/^([0-9]+):([0-9]+)$/", $rate, $matches);
					if($matches[1]+1 == $this->Config['api'][$matches[2]])
						$this->setRetryAfter($RequestParams["region"], time()+$matches[2]);
				}
			}

			// Retry-Ater
			if(preg_match("/Retry-After: ([0-9]+)/", $curl_result["header"], $matches))
				$this->setRetryAfter($RequestParams["region"], time()+$matches[1]);
			*/
			
			// HTTP Code filter
			switch($curl_result["http_code"])
			{
				case DataProvider::OK:
					// OK.
					$data["_id"] = sha1($url); // Hash url for unique ID
					$data["request"] = $url; // URL request
					$data["result"] = $curl_result["body"]; // Request result
					$data["time"] = time(); // Current time
					
					$bulk = new MongoDB\Driver\BulkWrite;
					$bulk->update(['_id' => $data["_id"]], ['$set' => $data], ['upsert' => true, 'multi' => false]);
					$writeConcern = new MongoDB\Driver\WriteConcern(MongoDB\Driver\WriteConcern::MAJORITY, 1000);
					$this->MongoDB->executeBulkWrite('gromp.cache_api', $bulk, $writeConcern);
					
					$returnValue = $curl_result["body"];
				break;
				
				case DataProvider::BadRequest:
					// Bad request.
					$returnValue = $this->getCachedRequest($url);
					if($returnValue === false)
						$returnValue = $this->json_formatted_error(DataProvider::BadRequest, "Bad request.");
				break;

				case DataProvider::Unautorized:
					// Unauthorized.
					$returnValue = $this->getCachedRequest($url);
					if($returnValue === false)
						$returnValue = $this->json_formatted_error(DataProvider::Unautorized, "Unauthorized.");
				break;

				case DataProvider::NotFound:
					// No summoner data found for any specified inputs.
					$returnValue = $this->getCachedRequest($url);
					if($returnValue === false)
						$returnValue = $this->json_formatted_error(DataProvider::NotFound, "No summoner data found for any specified inputs.");
				break;

				case DataProvider::RateLimitExceeded:
					// Rate limit exceeded.
					$returnValue = $this->getCachedRequest($url);
					if($returnValue === false)
						$returnValue = $this->json_formatted_error(DataProvider::RateLimitExceeded, "Rate limit exceeded.");
				break;

				case DataProvider::InternalServerError:
					// Internal server error.
					$returnValue = $this->getCachedRequest($url);
					if($returnValue === false)
						$returnValue = $this->json_formatted_error(DataProvider::InternalServerError, "Internal server error.");
				break;

				case DataProvider::ServiceUnavailable:
					// Service unavailable.
					$returnValue = $this->getCachedRequest($url);
					if($returnValue === false)
						$returnValue = $this->json_formatted_error(DataProvider::ServiceUnavailable, "Service unavailable.");
				break;
			}
			
			$this->logDataProviderStatistics($curl_result["http_code"], $curl_result["header"], $url);
		}
		
		$memcache_obj->set('Gromp_RateLimit-'.$region, serialize($RateLimit));
		$memcache_obj->delete('Gromp_RateLimitMutex-'.$region);
		
		return $returnValue;
	}
	
	
	
	
	/* This function log into mongodb statistics about API League of Legends error based on HTTP Code response.
	 * So we can analyse what goes wrong.
	 */
	private function logDataProviderStatistics($http_code, $http_header, $url)
	{
		// DataProvider statistics
		$statistics["_id"] = sha1($url); // Hash url for unique ID
		$statistics["http_code"] = $http_code;
		$statistics["http_header"] = $http_header;
		$statistics["url"] = $url;
		$statistics["time"] = time();
		$statistics["counter"] = 1;
		
		$mongodb_query = new MongoDB\Driver\Query(['_id' => sha1($url)]);
		$rows = $this->MongoDB->executeQuery('gromp.dataprovider_statistics', $mongodb_query);
		$rows = $rows->toArray();
		
		$bulk = new MongoDB\Driver\BulkWrite;
		if(count($rows) === 0)
		{
			// Create a new record
			$bulk->update(['_id' => $statistics["_id"]],
						  ['$set' => $statistics],
						  ['upsert' => true, 'multi' => false]);
		}
		else
		{
			// Record already exists, update counter
			$bulk->update(['_id' => $statistics["_id"]],
						  ['$inc' => ['counter' => 1]],
						  ['upsert' => false, 'multi' => false]);
		}
		
		$writeConcern = new MongoDB\Driver\WriteConcern(MongoDB\Driver\WriteConcern::MAJORITY, 1000);
		$this->MongoDB->executeBulkWrite('gromp.dataprovider_statistics', $bulk, $writeConcern);	
	}
}
?>
